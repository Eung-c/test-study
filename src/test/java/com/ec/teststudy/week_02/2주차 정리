[ 2장 리팩터링 원칙]

1.리펙터링?
 1.1 리팩터링 : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.

 1.2 리펙터링의 장점
      a. 소프트웨어 설계가 좋아진다.
      b. 소프트웨어 이해가 쉬워진다.
      c. 버그를 쉽게 찾을 수 있다.
      d. 프로그래밍 속도를 높일 수 있다.


2. 리펙터링은 언제?
 2.1 3법의법칙 : 1,2번 봐주다가 3번 거슬리면 그때 해라 
 2.2 리펙터링은 언제?
     준비를 위한 리펙터링, 이해를 위한 리펙터링, 쓰레기 줍기 리펙토링
     철저히 준비를 하고 충분히 이해 하고 정리 한 다음 
     
     너무 많은 사람들이 달라들어서 하는건 좋지 않음. 그냥 수시로(저자는 1시간에 한번씩 한다) 주기적으로 하는게 좋음.
     외부 연계와 같은 복잡한 롤이나 건들면 ㅈ되겠다 싶은건 하지 말자. ㅎ
     
3. 리펙터링 시 고려할 문제
 3.1 속도 저하
     리펙터링을 통해 성능의 변화를 기대할 순 없다. 리펙터링과 성능의 변화를 구분지어 작업이 필요하다.
     꾸준한
 3.2 XP(eXtreme Programming)
     CI(지속적인 통합)+리펙터링. 브런치의 통합 주기를 최대한 짧게 유지하는게 좋다.
 3.3 테스팅
     리펙터링하는 과정에서 충분한 테스팅을 통해 넓고 튼튼한 테스트 커버리지를 필요하다. 
 3.4 데이터베이스
     커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 
     대한 구조적 변경을 이 스크립트로 처리하는게 좋다. 그리고 더더더 잘게 쪼개서 처리하는게 필요하다.
 3.5 성능분석
     내가 아무리 많이 안다고 생각해도 건방지게 굴지 말고 성능분석을 통해 충분히 분석을 해보는게 좋다.
  
 4. 개발 프로세스
  4.1 TDD(Test-Driven Development)
      자가 테스트 코드 + 리펙터링
  4.2 자가 테스트 코드, 지속적인 통합, 리펙터링이 세개가 핵심.
  
 [ 3장 코드에서 나는 악취]
 
 1. 리펙터링 타이밍 잡기
   1.1 이상한 이름
   1.2 중복 코드
   1.3 긴 함수
   1.4 긴 파타미터
   1.5 전역 데이터
   1.6 가변데이터
   1.7 뒤어킨 변경
   1.8 산탕총 수술
   1.9 기능 편애
   1.10 데이터 뭉치
   1.11 기본형 집착
   1.12 반복되는 swich 문
   1.13 반복문
   1.14 성의 없는 요소
   1.15 추측성 일반화
   1.16 임시 필드
   1.17 메시지 체인
   1.18 중개자
   1.19 내부자 거래
   1.20 거대한 클래스
   1.21 서로 다른 이터페이스의 대안 클래스
   1.22 데이터 클래스
   1.23 상속 포기
   1.24 주석
   
  https://wikidocs.net/597
